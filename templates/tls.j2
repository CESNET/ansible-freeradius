# ansible managed do not touch!

######################################################################
#
#  Initial implementation of RADIUS over TLS (radsec)
#
######################################################################

listen {
	ipaddr = *
	port = 2083

	type = auth+acct

	proto = tcp

	# Send packets to the default virtual server
	virtual_server = default

	clients = radsec

	limit {
	      max_connections = 16

	      lifetime = 0

	      idle_timeout = 30
	}

	tls {
		private_key_file = ${certdir}/{{ ansible_fqdn}}.key
		certificate_file = ${certdir}/{{ ansible_fqdn}}.crt

		ca_file = ${cadir}/chain_CESNET_CA3.pem

		dh_file = ${certdir}/dh

		fragment_size = 8192

		#  Check the Certificate Revocation List
		#
		#  1) Copy CA certificates and CRLs to same directory.
		#  2) Execute 'c_rehash <CA certs&CRLs Directory>'.
		#    'c_rehash' is OpenSSL's command.
		#  3) uncomment the line below.
		#  5) Restart radiusd
	#	check_crl = yes
		ca_path = ${cadir}

		cipher_list = "DEFAULT"

		#
		#  Session resumption / fast reauthentication
		#  cache.
		#
		#  The cache contains the following information:
		#
		#  session Id - unique identifier, managed by SSL
		#  User-Name  - from the Access-Accept
		#  Stripped-User-Name - from the Access-Request
		#  Cached-Session-Policy - from the Access-Accept
		#
		#  The "Cached-Session-Policy" is the name of a
		#  policy which should be applied to the cached
		#  session.  This policy can be used to assign
		#  VLANs, IP addresses, etc.  It serves as a useful
		#  way to re-apply the policy from the original
		#  Access-Accept to the subsequent Access-Accept
		#  for the cached session.
		#
		#  On session resumption, these attributes are
		#  copied from the cache, and placed into the
		#  reply list.
		#
		#  You probably also want "use_tunneled_reply = yes"
		#  when using fast session resumption.
		#
		cache {
		      #
		      #  Enable it.  The default is "no".
		      #  Deleting the entire "cache" subsection
		      #  Also disables caching.
		      #
		      #  You can disallow resumption for a
		      #  particular user by adding the following
		      #  attribute to the control item list:
		      #
		      #		Allow-Session-Resumption = No
		      #
		      #  If "enable = no" below, you CANNOT
		      #  enable resumption for just one user
		      #  by setting the above attribute to "yes".
		      #
		      enable = no

		      #
		      #  Lifetime of the cached entries, in hours.
		      #  The sessions will be deleted after this
		      #  time.
		      #
		      lifetime = 24 # hours

		      #
		      #  The maximum number of entries in the
		      #  cache.  Set to "0" for "infinite".
		      #
		      #  This could be set to the number of users
		      #  who are logged in... which can be a LOT.
		      #
		      max_entries = 255

		      #
		      #  Internal "name" of the session cache.
		      #  Used to distinguish which TLS context
		      #  sessions belong to.
		      #
		      #  The server will generate a random value
		      #  if unset. This will change across server
		      #  restart so you MUST set the "name" if you
		      #  want to persist sessions (see below).
		      #
		      #  If you use IPv6, change the "ipaddr" below
		      #  to "ipv6addr"
		      #
		      #name = "TLS ${..ipaddr} ${..port} ${..proto}"

		      #
		      #  Simple directory-based storage of sessions.
		      #  Two files per session will be written, the SSL
		      #  state and the cached VPs. This will persist session
		      #  across server restarts.
		      #
		      #  The server will need write perms, and the directory
		      #  should be secured from anyone else. You might want
		      #  a script to remove old files from here periodically:
		      #
		      #    find ${logdir}/tlscache -mtime +2 -exec rm -f {} \;
		      #
		      #  This feature REQUIRES "name" option be set above.
		      #
		      #persist_dir = "${logdir}/tlscache"
		}

		#
		#  Require a client certificate.
		#
		require_client_cert = yes

		#
		#  As of version 2.1.10, client certificates can be
		#  validated via an external command.  This allows
		#  dynamic CRLs or OCSP to be used.
		#
		#  This configuration is commented out in the
		#  default configuration.  Uncomment it, and configure
		#  the correct paths below to enable it.
		#
		verify {
			#  A temporary directory where the client
			#  certificates are stored.  This directory
			#  MUST be owned by the UID of the server,
			#  and MUST not be accessible by any other
			#  users.  When the server starts, it will do
			#  "chmod go-rwx" on the directory, for
			#  security reasons.  The directory MUST
			#  exist when the server starts.
			#
			#  You should also delete all of the files
			#  in the directory when the server starts.
	#     		tmpdir = /tmp/radiusd

			#  The command used to verify the client cert.
			#  We recommend using the OpenSSL command-line
			#  tool.
			#
			#  The ${..ca_path} text is a reference to
			#  the ca_path variable defined above.
			#
			#  The %{TLS-Client-Cert-Filename} is the name
			#  of the temporary file containing the cert
			#  in PEM format.  This file is automatically
			#  deleted by the server when the command
			#  returns.
	#    		client = "/path/to/openssl verify -CApath ${..ca_path} %{TLS-Client-Cert-Filename}"
		}
	}
}

clients radsec {
	client 127.0.0.1 {
		ipaddr = 127.0.0.1
		proto = tls
		secret = radsec
	}
	client radius1.eduroam.cz {   
	       ipaddr = 195.113.187.22 
	       proto = tls             
               secret = radsec      
        }    
	client radius1.eduroam.cz { # druhy uzel narodniho RADIUSu - nepouziva se, jen pro manualni testy
	       ipaddr = 195.113.187.55
	       proto = tls             
               secret = radsec      
        }    
	client radius1.eduroam.cz { # prvni uzel narodniho RADIUSu - nepouziva se, jen pro manualni testy
	       ipaddr = 195.113.187.41 
	       proto = tls             
               secret = radsec      
        }    
}

home_server tls {
	ipaddr = 195.113.187.22
	port = 2083
	type = auth
	secret = radsec
	proto = tcp
	status_check = none
	
	# Po tomto poctu timeoutu se spusti zombie_period; max 1000
	response_timeouts = 1000

	# Pokud v tomhle okne neodpovi na dotaz je povazovan za zombie a zombie_period zacina - max 30
	# LOG: Proxy: Marking home server 195.113.187.22 port 2083 as zombie (it has not responded in 10.000000 seconds).
	response_window = 30

	# V tuhle dobu zacne posilat status-server (tedy kdyz zrovna
        # neni zakazany protoze TCP) a jeste ho neoznaci za mrtvy. Ale
        # asi i kdyz je vyply ho necha zit po tuto dobu.
	# LOG: Proxy: Marking home server 195.113.187.22 port 2083 as dead.
        zombie_period = 120

	# Interval po kterem je mrtvy server hozen zpatky mezi zive pokud je status_check = none; 60 je minimum
	# 
	# V logach se to projevuje hlaskou:
	# LOG: Proxy: Marking home server 195.113.187.22 port 2083 alive again... we have no idea if it really is alive or not.
	revive_interval = 60

	tls {
		private_key_file = ${certdir}/{{ ansible_fqdn}}.key
		certificate_file = ${certdir}/{{ ansible_fqdn}}.crt

		#  Trusted Root CA list
		ca_file = ${cadir}/chain_CESNET_CA3.pem

		dh_file = ${certdir}/dh
		random_file = /dev/urandom

		fragment_size = 8192

		#  Check the Certificate Revocation List
		#
		#  1) Copy CA certificates and CRLs to same directory.
		#  2) Execute 'c_rehash <CA certs&CRLs Directory>'.
		#    'c_rehash' is OpenSSL's command.
		#  3) uncomment the line below.
		#  5) Restart radiusd
	#	check_crl = yes
		ca_path = ${cadir}

		cipher_list = "DEFAULT"
	}

}

home_server_pool tls {
		 type = fail-over
		 home_server = tls
}

realm tls {
      auth_pool = tls
}
